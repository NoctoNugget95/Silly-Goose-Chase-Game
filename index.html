<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Silly Goose Chase</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barriecito&display=swap" rel="stylesheet">

    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #202020;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #game-stage {
            position: relative;
            width: 1280px;
            height: 720px;
            max-width: 100vw;
            max-height: 100vh;
            aspect-ratio: 16 / 9;
            background-color: #f0f0f0;
            background-image: 
                linear-gradient(#e0e0e0 1px, transparent 1px),
                linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
            background-size: 40px 40px;
            border: 4px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        @media (max-width: 1024px) {
            #game-stage {
                width: 100vw !important;
                height: 100dvh !important;
                max-width: none;
                max-height: none;
                aspect-ratio: auto;
                border: none;
                box-shadow: none;
                margin: 0;
                border-radius: 0;
            }

            #ui-layer {
                display: flex;
                flex-direction: column;
                justify-content: space-evenly;
                align-items: center;
                padding-bottom: 20px;
            }

            #main-title {
                position: static;
                font-size: 10vh;
                margin-top: 10px;
                line-height: 1.0;
            }

            .message-box {
                width: 80%;
                max-width: 400px;
                padding: 15px;
                margin: 0;
                background: rgba(255, 255, 255, 0.95);
            }

            #current-username-display { font-size: 6vh !important; }
            .message-box h1 { font-size: 8vh; }
            .message-box p { font-size: 4vh; }
            button { font-size: 4vh; padding: 10px 30px; }

            #score-display {
                font-size: 5vh;
                top: 10px; right: 15px;
            }
            #audio-controls {
                top: 10px; left: 15px;
                transform: scale(0.8);
                transform-origin: top left;
            }
        }

        /* Mobile landscape lock (added) */
        @media (orientation: landscape) and (max-width: 1024px) {
            #game-stage {
                aspect-ratio: 16 / 9;
                width: 100vw;
                height: auto;
                max-height: 100vh;
            }
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #main-title {
            position: absolute;
            top: 2%;
            width: 100%;
            text-align: center;
            font-family: 'Barriecito', cursive;
            font-size: 5rem;
            color: #d32f2f;
            text-shadow: 4px 4px 0px #000;
            margin: 0;
            z-index: 30;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .hidden { display: none !important; }

        .message-box {
            display: none;
            pointer-events: auto;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 25px;
            background: #ffffff;
            border: 6px solid #000;
            border-radius: 30px;
            padding: 40px;
            text-align: center;
            box-shadow: 15px 15px 0px rgba(0,0,0,0.2);
            min-width: 300px;
            font-size: 2rem;
            font-family: 'Barriecito', cursive;
            z-index: 20;
            margin-top: 50px;
        }

        .message-box.active { display: flex !important; }

        button {
            background: #ffeb3b;
            border: 4px solid #000;
            padding: 15px 40px;
            font-size: 1.8rem;
            font-family: inherit;
            cursor: pointer;
            border-radius: 12px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        #start-rev-img {
            position: absolute;
            right: -10%;
            bottom: -15%;
            height: 90%;
            width: auto;
            scale: 1.1;
            object-fit: contain;
            pointer-events: none;
            z-index: 1;
        }

        #start-goose-img {
            position: absolute;
            left: -5%;
            bottom: 0%;
            height: 60%;
            width: auto;
            object-fit: contain;
            pointer-events: none;
            z-index: 1;
        }

        #game-stage.blueprint-mode {
            background-color: #0d47a1;
        }

        #audio-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            height: 40px;
            background: rgba(255,255,255,0.8);
            border: 2px solid #333;
            border-radius: 20px;
            display: flex;
            align-items: center;
            pointer-events: auto;
            z-index: 1001;
            width: 40px;
            overflow: hidden;
            transition: width 0.2s ease-out;
        }

        #audio-controls:hover {
            width: 160px;
        }

        #mute-btn {
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            user-select: none;
        }

        #volume-slider {
            width: 100px;
            margin-left: 5px;
            margin-right: 10px;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease-in;
        }

        #audio-controls:hover #volume-slider {
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.3s ease-out 0.1s;
        }

        #score-display {
            position: absolute;
            top: 25px;
            right: 30px;
            font-size: 2rem;
            font-family: 'Barriecito', cursive;
            color: #333;
            text-shadow: 2px 2px 0px #fff;
            z-index: 50;
            pointer-events: none;
            user-select: none;
        }

        #rotate-message {
            display: none !important;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #202020;
            color: #fff;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        @media only screen and (orientation: portrait) and (max-width: 768px) {
            #rotate-message { display: flex !important; }
            #game-stage { display: none !important; }
        }

        #pause-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 900;
            pointer-events: auto;
            backdrop-filter: blur(2px);
        }

        #pause-overlay.active { display: flex !important; }

        .pause-title {
            font-family: 'Barriecito', cursive;
            font-size: 6rem;
            color: #fff;
            text-shadow: 4px 4px 0px #000;
            margin: 0;
            letter-spacing: 5px;
        }

        .pause-subtitle {
            font-family: 'Comic Sans MS', sans-serif;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 2px 2px 0px #000;
            margin-top: 10px;
        }

        .desktop-hint { display: block; }
        .mobile-hint { display: none; }

        @media (hover: none) and (pointer: coarse) {
            .desktop-hint { display: none; }
            .mobile-hint { display: block; }
        }
    </style>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>

<div id="rotate-message">
    <div style="font-size: 50px; margin-bottom: 20px;">üîÑ</div>
    <h1>Please Rotate Device</h1>
    <p>This game is best played in Landscape mode!</p>
</div>

<div id="game-stage">
    <canvas id="gameCanvas"></canvas>
    
    <div id="score-display">Score: 0</div>

    <div id="audio-controls">
        <div id="mute-btn">üîä</div>
        <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="0.5">
    </div>

    <div id="ui-layer">
        <h1 id="main-title">Silly Goose Chase</h1>

        <div id="start-screen" class="message-box active">
            <div id="change-user-btn" style="background: #e3f2fd; border: 4px solid #0d47a1; border-radius: 20px; padding: 10px 15px; margin-bottom: 15px; cursor: pointer; box-shadow: 4px 4px 0px  #0a2472; transition: transform 0.1s; text-align: center; font-family: 'Barriecito', cursive;">
                <div style="color: #0d47a1; font-size: 1.3rem; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 1px;">PICK A NAME!!!</div>
                <div style="font-size: 2.8rem; color: #1a1a1a; line-height: 1.0; text-shadow: 2px 2px 0px #fff;">
                    <span id="current-username-display">Guest</span> 
                    <span style="font-size: 1.8rem; color: #1976d2; vertical-align: middle;">‚úé</span>
                </div>
                <div style="border-bottom: 3px dotted #1976d2; width: 70%; margin: 5px auto; opacity: 0.6;"></div>
                <div style="color: #0d47a1; font-size: 1rem;">Show <span style="color:#000">the world</span> who's <span style="color:#000">top goose!</span></div>
            </div>

            <button id="start-btn">Start Flying</button>

            <div id="leaderboard-container" style="margin-top: 15px; width: 100%;">
                <h3 style="margin: 0 0 5px 0; font-size: 1.4rem; color: #333; text-decoration: none; border-bottom: 2px solid #333; display: inline-block; padding-bottom: 2px;">Global Top 5</h3>
                <div id="leaderboard-list" style="font-size: 1rem; text-align: left; background: #fff; padding: 0; border: none; min-height: 80px;">
                    <div style="color: #999; padding: 10px;">Loading scores...</div>
                </div>
            </div>
        </div>
        
        <img id="start-rev-img" alt="Rev" style="display:block;">
        <img id="start-goose-img" alt="Goose" style="display:block;">
        
        <div id="game-over-screen" class="message-box">
            <h1>Silly Goose!</h1>
            <p>Your Score: <span id="final-score">0</span></p>
            <p style="font-size: 1.5rem; color: #d32f2f;">Your Best: <span id="best-score-display">0</span></p>
            <button id="restart-btn">Try Again</button>
        </div>

        <div id="pause-overlay">
            <h1 class="pause-title">PAUSED</h1>
            <p class="pause-subtitle desktop-hint">Click Anywhere or Press Spacebar to Resume</p>
            <p class="pause-subtitle mobile-hint">Tap Anywhere to Resume</p>
        </div>
    </div>
    
    <div id="loading">Loading...</div>
</div>

<script>

    window.onerror = function(msg, url, lineNo, columnNo, error) {
        const loader = document.getElementById('loading');
        if(loader) {
            loader.className = 'error';
            loader.innerHTML = "<strong>‚ö†Ô∏è Game Crashed!</strong><br><br>" + msg + "<br><br>Check Line: " + lineNo;
            loader.style.display = 'flex';
        }
        return false;
    };
</script>

<script>
    let db = null;
    let currentUser = localStorage.getItem('sillyGooseUsername') || "Guest";
    let highScore = parseInt(localStorage.getItem('sillyGooseHighScore')) || 0;

    try {
        // SENIOR DEV REVIEW: The API key below is exposed on the client-side.
        // For a production application, this key should be restricted to your domain
        // and you should use Firebase security rules to protect your data.
        const firebaseConfig = {
            apiKey: "AIzaSyA4eP_ypqzLq1KvKe8ffbdQJZTmh9iaKzM",
            authDomain: "silly-goose-chase.firebaseapp.com",
            projectId: "silly-goose-chase",
            storageBucket: "silly-goose-chase.firebasestorage.app",
            messagingSenderId: "178014526530",
            appId: "1:178014526530:web:bef279b366275b7b1761db"
        };

        if (typeof firebase !== 'undefined') {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            console.log("Firebase connected.");
            fetchLeaderboard();
        }
    } catch (err) {
        console.warn("Offline Mode:", err);
        const listDiv = document.getElementById('leaderboard-list');
        if(listDiv) listDiv.innerText = "Offline Mode";
    }

    function fetchLeaderboard() {
        if (!db) return;
        db.collection("leaderboard").orderBy("score", "desc").limit(5).get()
          .then((snapshot) => {
              const listDiv = document.getElementById('leaderboard-list');
              if(!listDiv) return;
              let html = ""; let rank = 1;
              snapshot.forEach((doc) => {
                  const data = doc.data();
                  let icon = rank === 1 ? "üëë" : (rank === 2 ? "ü•à" : (rank === 3 ? "ü•â" : `#${rank}`));
                  const isMe = data.name === currentUser ? "color:#d32f2f; font-weight:bold;" : "";
                  html += `<div style="display:flex; justify-content:space-between; ${isMe}"><span>${icon} ${data.name}</span><span>${data.score}</span></div>`;
                  rank++;
              });
              if (html === "") html = "No scores yet.";
              listDiv.innerHTML = html;
          })
          .catch((error) => { console.log("Error getting scores:", error); });
    }

    function trySaveScore(newScore) {
        if (newScore > highScore) {
            highScore = newScore;
            localStorage.setItem('sillyGooseHighScore', highScore);
            updateUserDisplay();
        }

        if (db && currentUser !== "Guest") {
            db.collection("leaderboard").doc(currentUser).set({
                name: currentUser,
                score: newScore,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            })
            .then(() => {
                fetchLeaderboard();
            })
            .catch((err) => console.error("Cloud save failed", err));
        }
    }

    function updateUserDisplay() {
        const el = document.getElementById('current-username-display');
        if (el) el.innerText = currentUser;
        const bestEl = document.getElementById('best-score-display');
        if (bestEl) bestEl.innerText = highScore;
    }

    window.changeUser = function() {
        const newName = prompt("Enter username:", currentUser);
        if (newName) {
            currentUser = newName.trim();
            localStorage.setItem('sillyGooseUsername', currentUser);
            highScore = 0;
            localStorage.setItem('sillyGooseHighScore', 0);
            updateUserDisplay();
        }
    };

    // ==========================================
    // --- GAME CONSTANTS & CONFIG ---
    // ==========================================

    const PERMANENT_PLAYER_SVG = `sprite.png`;
    const SECRET_PLAYER_SRC = `secret_player.png`;
    const START_SCREEN_GOOSE_SRC = `goose.png`;
    const START_SCREEN_REV_SRC = `rev.png?v=2`;

    const AUDIO_FILES = {
        jump: "jump.wav", coin1: "coin1.wav", coin2: "coin2.wav",
        powerup: "powerup.wav", music_main: "music_main.wav", music_clash: "music_clash.wav",
        music_start: "music.start.wav"
    };

    // FIX 1: GAME SPEED SYSTEM
    let GAME_SPEED = 5.0;
    const SECRET_LEVEL_SPEED = 8;
    let lastFrameTime = performance.now();
    let deltaTime = 1.0;

    const CONFIG = {
        gravity: 900,
        jumpStrength: -350,
        spawnDistance: 600,
        gapSize: 255,
        playerScale: 0.15,
        doodleWobbleSpeed: 0.1,
        clashDuration: 300,
        batterySpawnChance: 0.05,
        coinChancePerGap: 0.4
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let frames = 0; let score = 0; let startFreeze = 0;
    let isGameOver = false; let isPlaying = false;
    let isClashing = false; let clashTimer = 0;
    let doodleTime = 0; let isPaused = false;
    let isLooping = false;

    const secretMode = { active: false, timer: 0, maxDuration: 300, scoreAccumulator: 0, coinAccumulator: 0 };
    const battery = { active: false, x: 0, y: 0, width: 30, height: 50, wobble: 0 };
    const player = { x: 0, y: 0, width: 50, height: 50, velocity: 0, rotation: 0, baseX: 0, baseY: 0 };
    const goose = { x: -100, y: 0, targetX: 50, frame: 0 };

    let obstacles = []; let particles = []; let clashCloudParticles = [];
    let bgElements = []; let coins = []; let scoreFloater = [];

    const playerImg = new Image();
    playerImg.onerror = function() { playerImg.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjMjliNmY2Ii8+PC9zdmc+"; };
    if (PERMANENT_PLAYER_SVG) playerImg.src = PERMANENT_PLAYER_SVG.trim();

    const secretPlayerImg = new Image();
    if (SECRET_PLAYER_SRC) secretPlayerImg.src = SECRET_PLAYER_SRC.trim();

    const revImg = document.getElementById('start-rev-img');
    const gooseImg = document.getElementById('start-goose-img');
    if (START_SCREEN_REV_SRC && revImg) revImg.src = START_SCREEN_REV_SRC.trim();
    if (START_SCREEN_GOOSE_SRC && gooseImg) gooseImg.src = START_SCREEN_GOOSE_SRC.trim();

    // ==========================================
    // --- AUDIO SYSTEM ---
    // ==========================================

    const AudioSys = {
        ctx: null, isPlaying: false, isMuted: false, tempo: 1.45,
        masterVolume: 0.5, customBuffers: {}, activeSource: null, bgMusicGainNode: null,
        nextNoteTime: 0, noteIndex: 0, currentTrack: 'main',

        N: { G2: 98, A2: 110, C3: 130.81, E3: 164.81, G3: 196, A4: 440, Cs5: 554.37, E5: 659.25 },
        tracks: {
            main: [ {f: 'A4', d: 0.15}, {f: 'C5', d: 0.15}, {f: 'E5', d: 0.15}, {f: 0, d: 0.15} ],
            clash: [ {f: 'C4', d: 0.1}, {f: 'Cs4', d: 0.1}, {f: 0, d: 0.1} ]
        },

        init: function() {
            return new Promise((resolve) => {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    const promises = [];
                    const loadBuffer = (key, path) => {
                        if (!path) return;
                        const promise = fetch(path)
                            .then(r => r.arrayBuffer())
                            .then(b => this.ctx.decodeAudioData(b))
                            .then(d => { this.customBuffers[key] = d; })
                            .catch(e => { console.warn(`Audio file ${key} could not be loaded.`) });
                        promises.push(promise);
                    };

                    for (let k in AUDIO_FILES) loadBuffer(k, AUDIO_FILES[k]);
                    if (AUDIO_FILES.music_main) loadBuffer('main', AUDIO_FILES.music_main);
                    if (AUDIO_FILES.music_clash) loadBuffer('clash', AUDIO_FILES.music_clash);
                    if (AUDIO_FILES.music_start) {
                        loadBuffer('music_start', AUDIO_FILES.music_start);
                        loadBuffer('start_screen', AUDIO_FILES.music_start);
                    }

                    Promise.all(promises).then(() => {
                        if (!this.customBuffers['music_main'] && this.customBuffers['main']) this.customBuffers['music_main'] = this.customBuffers['main'];
                        if (!this.customBuffers['music_clash'] && this.customBuffers['clash']) this.customBuffers['music_clash'] = this.customBuffers['clash'];
                        resolve();
                    });
                } catch(e) {
                    console.error("Audio system initialization failed.", e);
                    resolve(); // Resolve anyway to not hang the game
                }
            });
        },

        toggleMute: function() {
            this.isMuted = !this.isMuted;
            document.getElementById('mute-btn').innerText = this.isMuted ? "üîá" : "üîä";
            if(this.ctx) this.isMuted ? this.ctx.suspend() : this.ctx.resume();
        },

        setVolume: function(val) {
            this.masterVolume = parseFloat(val);
            if (this.masterVolume > 0 && this.isMuted) this.toggleMute();
            if (this.bgMusicGainNode) this.bgMusicGainNode.gain.setValueAtTime(0.1 * this.masterVolume, this.ctx.currentTime);
        },

        playTone: function(freq, duration, type = 'triangle', vol = 0.1) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type; osc.frequency.value = freq;
            const effectiveVol = Math.max(0.001, vol * this.masterVolume);
            gain.gain.setValueAtTime(effectiveVol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + duration);
        },

        playTrack: function(trackName) {
            // ensure audio context exists (init on first user gesture)
            if (!this.ctx) return;
            if (this.activeSource) { try { this.activeSource.stop(); } catch(e){} }
            this.currentTrack = trackName;
            this.isPlaying = true;
            let bufferKey = trackName;
            if(trackName === 'start_screen') bufferKey = 'music_start';
            if (!this.customBuffers[bufferKey]) { return; }

            const source = this.ctx.createBufferSource();
            source.buffer = this.customBuffers[bufferKey];
            source.loop = true;
            const gain = this.ctx.createGain();
            gain.gain.value = 0.1 * this.masterVolume;
            source.connect(gain); gain.connect(this.ctx.destination);
            source.start();
            this.activeSource = source;
            this.bgMusicGainNode = gain;
        },

        stopMusic: function() {
            this.isPlaying = false;
            if (this.activeSource) { try{this.activeSource.stop();}catch(e){}; this.activeSource=null; }
        },

        update: function() { },

        playSound: function(name) {
            // ensure audio context exists (init on first user gesture)
            if (!this.ctx || this.isMuted) return;
            let key = name;
            if (name === 'coin') key = Math.random() > 0.5 ? 'coin1' : 'coin2';

            if (this.customBuffers[key]) {
                const src = this.ctx.createBufferSource();
                src.buffer = this.customBuffers[key];
                const g = this.ctx.createGain();
                let vol = 0.6;
                if (key === 'coin2') vol = 3.0;
                if (key === 'powerup') vol = 6.6;
                g.gain.value = vol * this.masterVolume;
                src.connect(g); g.connect(this.ctx.destination);
                src.start();
            } else {
                if(name==='jump') this.playTone(300, 0.1, 'triangle', 0.1);
                if(name==='coin') this.playTone(1200, 0.1, 'sine', 0.3);
            }
        }
    };

    // ==========================================
    // --- DRAWING FUNCTIONS ---
    // ==========================================

    function drawWobblyLine(x1, y1, x2, y2, color, thickness) {
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = thickness; ctx.lineCap = 'round';
        const segments = Math.max(2, Math.floor(Math.abs(x2 - x1 + y2 - y1) / 20));
        const dx = (x2 - x1) / segments; const dy = (y2 - y1) / segments;
        ctx.moveTo(x1, y1);
        for (let i = 1; i <= segments; i++) {
            const offsetX = Math.sin(doodleTime + i) * 2; const offsetY = Math.cos(doodleTime + i * 2) * 2;
            ctx.lineTo(x1 + dx * i + offsetX, y1 + dy * i + offsetY);
        }
        ctx.stroke();
    }

    function drawDoodleRect(x, y, w, h, fillColor, strokeColor) {
        ctx.fillStyle = fillColor;
        ctx.beginPath(); ctx.moveTo(x + 2, y + 2); ctx.lineTo(x + w - 2, y + 5);
        ctx.lineTo(x + w - 5, y + h - 2); ctx.lineTo(x + 3, y + h - 5); ctx.closePath(); ctx.fill();
        drawWobblyLine(x, y, x + w, y, strokeColor, 3); drawWobblyLine(x + w, y, x + w, y + h, strokeColor, 3);
        drawWobblyLine(x + w, y + h, x, y + h, strokeColor, 3); drawWobblyLine(x, y + h, x, y, strokeColor, 3);
        ctx.beginPath(); ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 2;
        for(let i=10; i<w; i+=15) { ctx.moveTo(x + i, y + 5); ctx.lineTo(x + i - 5, y + h - 5); } ctx.stroke();
    }

    function drawClouds(frames, isBlueprint) {
        ctx.fillStyle = isBlueprint ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.5)"; 
        ctx.beginPath();
        const t = frames * 0.002;
        for(let i = 0; i < 5; i++) {
             let cx = ((i * 300) + t * 100) % (canvas.width + 200) - 100;
             let cy = 50 + Math.sin(i + t) * 30;
             ctx.arc(cx, cy, 40, 0, Math.PI * 2);
             ctx.arc(cx + 30, cy - 10, 50, 0, Math.PI * 2);
             ctx.arc(cx + 60, cy, 40, 0, Math.PI * 2);
        }
        ctx.fill();
    }

    function drawPaperBackground() {
        ctx.beginPath(); ctx.strokeStyle = "rgba(173, 216, 230, 0.5)"; ctx.lineWidth = 1;
        const gridSize = 40;
        for (let x = 0; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for (let y = 0; y < canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();
        ctx.beginPath(); ctx.strokeStyle = "rgba(255, 182, 193, 0.8)"; ctx.lineWidth = 2;
        ctx.moveTo(60, 0); ctx.lineTo(60, canvas.height); ctx.stroke();
    }

    function drawBlueprintBackground() {
        ctx.beginPath(); ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"; ctx.lineWidth = 1;
        const gridSize = 40;
        for (let x = -canvas.height; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x + canvas.height, canvas.height); }
        ctx.stroke();
    }

    function drawSpaceDoodle(el) {
        ctx.save(); ctx.translate(el.x, el.y); ctx.rotate(el.rotation);
        ctx.strokeStyle = el.color; ctx.fillStyle = el.color.replace('0.2)', '0.05)'); 
        ctx.lineWidth = 2; ctx.lineCap = 'round';
        if (el.type === 'sun') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            for(let i=0; i<10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                ctx.moveTo(Math.cos(angle)*(el.size/2+5), Math.sin(angle)*(el.size/2+5));
                ctx.lineTo(Math.cos(angle)*(el.size/2+25), Math.sin(angle)*(el.size/2+25));
            }
            ctx.stroke();
        } else if (el.type === 'moon') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(-el.size/6, -el.size/6, el.size/6, 0, Math.PI*2); ctx.stroke();
        } else if (el.type === 'earth') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-el.size/3, -el.size/4); ctx.quadraticCurveTo(0, -el.size/2, el.size/3, -el.size/4); ctx.stroke();
        } else if (el.type === 'comet') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/3, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-el.size/3, 0); ctx.lineTo(-el.size*1.5, -el.size/3); ctx.stroke();
        } else if (el.type === 'asteroid') {
            ctx.beginPath(); 
            for(let i=0; i<=8; i++) {
                const angle = (i / 8) * Math.PI * 2; const r = el.size/2 + (Math.sin(i * 345) * 5); 
                i===0 ? ctx.moveTo(Math.cos(angle)*r, Math.sin(angle)*r) : ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
            }
            ctx.stroke();
        } else if (el.type === 'planet') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(0, 0, el.size/1.2, el.size/4, Math.PI/-6, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
    }

    function drawCoin(c, frames) {
        ctx.save(); ctx.translate(c.x, c.y);
        const scale = 1 + Math.sin(frames * 0.1 + c.wobbleOffset) * 0.1;
        ctx.scale(scale, scale);
        ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(0, 0, c.radius, 0, Math.PI*2); ctx.fill();
        drawWobblyLine(-c.radius, -c.radius*0.8, c.radius, -c.radius*0.8, "#000", 2); 
        ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 0, c.radius, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, c.radius * 0.7, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = "#fff"; ctx.font = `bold ${c.radius}px 'Comic Sans MS'`;
        ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(c.value, 0, 2);
        ctx.restore();
    }

    function drawFloater(f) {
        ctx.save(); ctx.globalAlpha = f.life / 60; ctx.fillStyle = f.color;
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.font = "bold 24px 'Comic Sans MS'";
        ctx.textAlign = "center"; ctx.fillText(f.text, f.x, f.y); ctx.strokeText(f.text, f.x, f.y); ctx.restore();
    }
    
    function drawBattery(x, y, frames) {
        drawDoodleRect(x, y, 30, 50, "#00e676", "#000"); 
        ctx.fillStyle = "#888"; ctx.fillRect(x + 7, y - 6, 16, 6);
        ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.strokeRect(x + 7, y - 6, 16, 6);
        if (frames % 20 < 10) { ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(x - 5, y - 5, 5, 0, Math.PI*2); ctx.fill(); }
    }

    function drawGoose(x, y, rotation, frames, isClashing, secretModeActive) {
        const wiggle = Math.sin(frames * 0.2) * 5;
        ctx.save(); ctx.translate(x, y); ctx.scale(1.3, 1.3); 
        if (rotation) ctx.rotate(rotation); 
        ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.ellipse(0, 0, 30, 20, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(20, -5); ctx.quadraticCurveTo(40, -15, 45 + wiggle/2, -30); ctx.stroke();
        ctx.beginPath(); ctx.arc(45 + wiggle/2, -30, 10, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "orange"; ctx.beginPath(); ctx.moveTo(53 + wiggle/2, -33); ctx.lineTo(65 + wiggle/2, -28); ctx.lineTo(53 + wiggle/2, -25); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(48 + wiggle/2, -32, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(45 + wiggle/2, -36); ctx.lineTo(52 + wiggle/2, -34); ctx.stroke();
        ctx.fillStyle = "white"; const wingY = Math.sin(frames * 0.5) * 15;
        ctx.beginPath(); ctx.moveTo(0, -5); ctx.quadraticCurveTo(10, -25 + wingY, -10, -10 + wingY); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = "orange"; ctx.beginPath(); ctx.moveTo(-5, 15); ctx.lineTo(-10 + wiggle, 25); ctx.moveTo(5, 15); ctx.lineTo(10 + wiggle, 28); ctx.stroke();
        if (!isClashing) {
            if (!secretModeActive && frames % 100 < 40 && !rotation) {
                ctx.font = "bold 20px 'Comic Sans MS'"; ctx.fillStyle = "red"; ctx.fillText("HONK!", 50, -50);
            } else if (secretModeActive && frames % 10 < 7) {
                 ctx.save(); ctx.translate((Math.random()-0.5)*8, (Math.random()-0.5)*8);
                 const size = 20 + Math.random() * 10; ctx.font = `bold ${size}px 'Comic Sans MS'`; 
                 ctx.fillStyle = Math.random() > 0.5 ? "red" : "#ff3333"; ctx.fillText("HONK!!", 50, -60); ctx.restore();
            }
        }
        ctx.restore();
    }

    function drawClashClouds(layer, clashCloudParticles) {
        clashCloudParticles.forEach(p => {
            if (p.layer !== layer) return;
            ctx.fillStyle = p.color; ctx.globalAlpha = (layer === 1) ? p.alpha * 0.6 : p.alpha;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = "#888"; ctx.lineWidth = 1; ctx.stroke();
        });
        ctx.globalAlpha = 1.0;
    }

    function drawLightning(centerX, centerY) {
        ctx.beginPath(); ctx.strokeStyle = Math.random() > 0.5 ? "#00ffff" : "#ffffff";
        ctx.lineWidth = 3 + Math.random() * 3;
        let lx = centerX - 20 + (Math.random() - 0.5) * 60; let ly = centerY - 200; 
        ctx.moveTo(lx, ly);
        for(let i=0; i<12; i++) { lx += (Math.random() - 0.5) * 60; ly += Math.random() * 60; ctx.lineTo(lx, ly); }
        ctx.shadowBlur = 15; ctx.shadowColor = "#00ffff"; ctx.stroke(); ctx.shadowBlur = 0; 
    }

    // ==========================================
    // --- GAME LOGIC ---
    // ==========================================

    function resize() {
        const stage = document.getElementById('game-stage');
        canvas.width = stage.clientWidth;
        canvas.height = stage.clientHeight;
        ctx.imageSmoothingEnabled = true;
        if (!isPlaying && !isClashing && player) {
            player.baseX = canvas.width * 0.30;
            player.x = player.baseX; player.y = canvas.height / 2;
        }
    }

    function createParticle(x, y, type) {
        let color = "rgba(0,0,0,0.2)"; if (type === 'spark') color = "#4fc3f7";
        particles.push({ x, y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 30, type, color });
    }

    function createBgElement(xOffset) {
        const types = ['asteroid', 'planet', 'sun', 'moon', 'earth', 'comet'];
        const type = types[Math.floor(Math.random() * types.length)];
        let size = 40 + Math.random() * 40;
        bgElements.push({ x: xOffset, y: Math.random() * canvas.height, type: type, size: size, speedFactor: 0.1 + Math.random() * 0.4, rotation: Math.random() * Math.PI * 2, color: `rgba(100, 116, 139, ${0.1 + Math.random() * 0.15})` });
    }

    function createObstacle(overrideX) {
        let x = (typeof overrideX === 'number') ? overrideX : canvas.width;
        const minH = 50, maxH = canvas.height - CONFIG.gapSize - minH;
        const topH = Math.floor(Math.random() * (maxH - minH + 1) + minH);

        obstacles.push({ x: x, topHeight: topH, bottomY: topH + CONFIG.gapSize, width: 70, passed: false, colorIndex: Math.floor(Math.random()*3) });

         let batterySpawned = false;
        if (score >= 30 && Math.random() < CONFIG.batterySpawnChance) {
            spawnBattery(x + CONFIG.spawnDistance / 2);
            batterySpawned = true;
        }

        if (!batterySpawned && Math.random() < CONFIG.coinChancePerGap) {
            const coinX = x + CONFIG.spawnDistance / 2;
            const coinY = 50 + Math.random() * (canvas.height - 100);
            createCoin(coinX, coinY);
        }
    }

    function createCoin(spawnX, spawnY) {
        const rand = Math.random();
        let value = 5, color = "#cd7f32", radius = 15;
        if (rand > 0.98) { value = 100; color = "#e91e63"; radius = 25; } else if (rand > 0.93) { value = 50; color = "#9c27b0"; radius = 22; } else if (rand > 0.75) { value = 20; color = "#2196f3"; radius = 20; } else if (rand > 0.45) { value = 10; color = "#c0c0c0"; radius = 18; }
        coins.push({ x: spawnX, y: spawnY, value: value, color: color, radius: radius, wobbleOffset: Math.random() * Math.PI * 2 });
    }

      function spawnBattery(overrideX) {
        if (!battery.active && !secretMode.active) {
             battery.active = true; 
            battery.x = (typeof overrideX === 'number') ? overrideX : (canvas.width + 100);
            let safeY = canvas.height / 2;
            if (obstacles.length > 0) safeY = obstacles[obstacles.length-1].topHeight + (CONFIG.gapSize / 2);
            battery.y = safeY + (Math.random() - 0.5) * 100;
        }
    }

    function jump() {
        if (!isPlaying || isGameOver || isClashing) return;
        if (startFreeze > 0) {
            startFreeze = 0;
        }

        player.velocity = CONFIG.jumpStrength;
        createParticle(player.x, player.y + player.height, 'jump');
        if (frames % 10 === 0) AudioSys.playSound('jump');
    }

    function startGame() {
        if (isPlaying || isClashing) return;

        if (AudioSys) {
            if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            AudioSys.playTrack('main');
            AudioSys.tempo = 1.45;
        }

        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('game-over-screen').classList.remove('active');
        document.getElementById('main-title').classList.add('hidden');
        document.getElementById('start-rev-img').style.display = 'none';
        document.getElementById('start-goose-img').style.display = 'none';
        document.getElementById('game-stage').classList.remove('blueprint-mode');

        player.baseX = canvas.width * 0.30;
        player.x = player.baseX;
        player.y = canvas.height / 2;
        player.velocity = 0;
        player.rotation = 0;

        goose.x = -150;
        goose.targetX = 150;
        obstacles = [];
        particles = [];
        coins = [];
        scoreFloater = [];
        bgElements = [];

        for(let i=0; i<6; i++) createBgElement(Math.random() * canvas.width);

        score = 0;
        document.getElementById('score-display').innerText = `Score: ${score}`;

        frames = 1;
        GAME_SPEED = GAME_SPEED || 5.0;
        secretMode.active = false;
        secretMode.scoreAccumulator = 0;
        secretMode.coinAccumulator = 0;
        battery.active = false;
        startFreeze = 180;
        createObstacle(canvas.width);

        isGameOver = false;
        isClashing = false;
        isPlaying = true;
        isPaused = false;

        if (!isLooping) {
            isLooping = true;
            loop();
        }
    }

    function update() {
        const now = performance.now();
        const dtSeconds = (now - lastFrameTime) / 1000;
        lastFrameTime = now;
        deltaTime = dtSeconds * 60;

        frames++;
        doodleTime += CONFIG.doodleWobbleSpeed * deltaTime;

        // FREEZE CHECK FIRST
        if (startFreeze > 0) {
            startFreeze -= deltaTime;
            const targetY = canvas.height / 2 + Math.sin(frames * 0.1) * 20;
            player.y += (targetY - player.y) * 0.1;
            player.velocity = 0;
            player.rotation = 0;

            for (let i = bgElements.length - 1; i >= 0; i--) {
                let el = bgElements[i];
                el.x -= GAME_SPEED * deltaTime * el.speedFactor;
                if (el.x < -el.size * 2) bgElements.splice(i, 1);
            }
            if (frames % 120 === 0) createBgElement(canvas.width + 100);
            return; // EXIT EARLY
        }

        // PHYSICS AFTER FREEZE
        player.velocity += CONFIG.gravity * dtSeconds;
        player.y += player.velocity * dtSeconds;
        player.rotation = Math.min(Math.PI/4, Math.max(-Math.PI/4, player.velocity*0.002));

        for (let i = bgElements.length - 1; i >= 0; i--) {
            let el = bgElements[i];
            el.x -= GAME_SPEED * deltaTime * el.speedFactor;
            if (el.x < -el.size * 2) bgElements.splice(i, 1);
        }
        if (frames % 120 === 0) createBgElement(canvas.width + 100);

        AudioSys.update();

        if (isClashing) {
            clashTimer -= deltaTime;
            const centerX = player.baseX;
            const centerY = player.baseY;
            goose.x += (centerX - 50 - goose.x) * 0.1;
            goose.y += (centerY - goose.y) * 0.1;
            player.x += (centerX + 50 - player.x) * 0.1;
            const t = frames * 0.1;
            goose.y = centerY + Math.sin(t) * 20;
            goose.x = centerX - 50 + Math.cos(t) * 10;
            player.y = centerY + Math.sin(t + Math.PI) * 20;
            player.x = centerX + 50 + Math.cos(t + Math.PI) * 10;
            player.rotation = Math.sin(t) * 0.1;

            if (frames % 2 === 0) clashCloudParticles.push({ x: centerX+(Math.random()-0.5)*80, y: centerY+(Math.random()-0.5)*60, radius: 30, maxRadius: 90+Math.random()*40, growth: 1.0+Math.random()*0.5, alpha: 1.0, color: Math.random()>0.5?'#fff':'#f4f4f4', layer: Math.random()>0.95?1:0 });
            for (let i = clashCloudParticles.length - 1; i >= 0; i--) {
                let p = clashCloudParticles[i];
                p.radius += p.growth * deltaTime;
                p.alpha -= 0.015 * deltaTime;
                if (p.alpha <= 0) clashCloudParticles.splice(i, 1);
            }

            if (clashTimer <= 0) {
                trySaveScore(score);
                AudioSys.stopMusic();
                isGameOver = true;
                isClashing = false;
                document.getElementById('final-score').innerText = score;
                document.getElementById('game-over-screen').classList.add('active');
            }
            return;
        }

        if (secretMode.active) {
           secretMode.timer -= deltaTime;
           secretMode.scoreAccumulator += deltaTime;
            if (secretMode.scoreAccumulator >= 10) {
                score++;
                document.getElementById('score-display').innerText = `Score: ${score}`;
                secretMode.scoreAccumulator -= 10;
            }
            if (secretMode.timer <= 0) {
                secretMode.active = false;
                AudioSys.tempo = 1.45;
                document.getElementById('game-stage').classList.remove('blueprint-mode');
                createParticle(player.x, player.y, 'jump');
                player.x = canvas.width * 0.30;
                obstacles = obstacles.filter(obs => obs.x > canvas.width * 0.8);
                coins = [];
            }
            secretMode.coinAccumulator += deltaTime;
            if (secretMode.coinAccumulator >= 20) {
                createCoin(canvas.width + 100, Math.random() * canvas.height);
                secretMode.coinAccumulator -= 20;
            }
        }

        if (battery.active) {
            battery.x -= GAME_SPEED * deltaTime;
            battery.wobble = Math.sin(frames * 0.1) * 5;

            const hitMargin = 40; // Expand hitbox to match visual sprite size
            if (player.x - hitMargin < battery.x + battery.width && player.x + player.width + hitMargin > battery.x &&
                player.y - hitMargin < battery.y + battery.height && player.y + player.height + hitMargin > battery.y) {

                AudioSys.playSound('powerup');
                secretMode.active = true;
                secretMode.timer = secretMode.maxDuration;
                battery.active = false;
                AudioSys.tempo = 1.6;
                document.getElementById('game-stage').classList.add('blueprint-mode');
                player.x = canvas.width * 0.6;
                for(let i=0; i<30; i++) createParticle(player.x + 25, player.y + 25, 'spark');
            }
            if (battery.x < -100) battery.active = false;
        }

        if (player.y + player.height > canvas.height || player.y < 0) {
            if (!secretMode.active) {
                AudioSys.playTrack('clash');
                isPlaying = false;
                isClashing = true;
                clashTimer = CONFIG.clashDuration;
                player.baseY = player.y;
            }
        }

        const lastObs = obstacles[obstacles.length - 1];
        if (!lastObs || (canvas.width - lastObs.x >= CONFIG.spawnDistance)) {
            createObstacle();
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= GAME_SPEED * deltaTime;

            if (player.x+10 < obs.x+obs.width && player.x+player.width-10 > obs.x &&
               (player.y+10 < obs.topHeight || player.y+player.height-10 > obs.bottomY)) {
                if (!secretMode.active) {
                    AudioSys.playTrack('clash');
                    isPlaying = false;
                    isClashing = true;
                    clashTimer = CONFIG.clashDuration;
                    player.baseY = player.y;
                }
            }

            if (obs.x + (obs.width / 2) < player.x && !obs.passed) {
                score++;
                obs.passed = true;
                AudioSys.playTone(1200, 0.1, 'sine', 0.6);
                document.getElementById('score-display').innerText = `Score: ${score}`;
            }
            if (obs.x < -100) obstacles.splice(i, 1);
        }

        for (let i = coins.length - 1; i >= 0; i--) {
            let c = coins[i];
            c.x -= GAME_SPEED * deltaTime;
            let dx = (player.x+25)-c.x, dy = (player.y+25)-c.y;

            if (Math.sqrt(dx*dx+dy*dy) < c.radius+25) {
                score += c.value;
                AudioSys.playSound('coin');
                document.getElementById('score-display').innerText = "Score: " + score;
                scoreFloater.push({x:c.x, y:c.y, text:"+"+c.value, life:60, vy:-2, color:c.color});
                coins.splice(i, 1);
            }
            if (c.x < -50) coins.splice(i, 1);
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.life -= deltaTime;
            if (p.life <= 0) particles.splice(i, 1);
        }

        for (let i = scoreFloater.length - 1; i >= 0; i--) {
            let f = scoreFloater[i];
            f.y += f.vy * deltaTime;
            f.life -= deltaTime;
            if (f.life <= 0) scoreFloater.splice(i, 1);
        }

        if (clashCloudParticles.length > 0) {
            for (let i = clashCloudParticles.length - 1; i >= 0; i--) {
                clashCloudParticles[i].alpha -= 0.015 * deltaTime;
                if (clashCloudParticles[i].alpha <= 0) clashCloudParticles.splice(i, 1);
            }
        }

        if (!isClashing && !secretMode.active) {
            goose.x += (goose.targetX - goose.x) * 0.05;
            goose.y += (player.y - goose.y) * 0.08;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (secretMode.active) drawBlueprintBackground(); else drawPaperBackground();
        bgElements.forEach(el => drawSpaceDoodle(el));
        drawClouds(frames, secretMode.active);

        const colors = ["#ffcc80", "#a5d6a7", "#90caf9"];
        const strokes = ["#e65100", "#1b5e20", "#0d47a1"];

        obstacles.forEach(obs => {
            if (secretMode.active) {
                ctx.save(); ctx.globalAlpha = 0.3;
                drawDoodleRect(obs.x, 0, obs.width, obs.topHeight, "#4fc3f7", "#fff");
                drawDoodleRect(obs.x, obs.bottomY, obs.width, canvas.height - obs.bottomY, "#4fc3f7", "#fff");
                ctx.restore();
            } else {
                drawDoodleRect(obs.x, 0, obs.width, obs.topHeight, colors[obs.colorIndex], strokes[obs.colorIndex]);
                drawDoodleRect(obs.x, obs.bottomY, obs.width, canvas.height - obs.bottomY, colors[obs.colorIndex], strokes[obs.colorIndex]);
            }
        });

        if (battery.active) drawBattery(battery.x, battery.y + battery.wobble, frames);
        coins.forEach(c => drawCoin(c, frames));

        if (isClashing) drawClashClouds(0, clashCloudParticles);

        if (secretMode.active) {
            ctx.save();
            const jitterX = (Math.random()-0.5)*15;
            const jitterY = (Math.random()-0.5)*15;
            let drawH = canvas.height * 0.85;
            let drawW = 300;

            if (secretPlayerImg.complete && secretPlayerImg.naturalHeight > 0) {
                drawW = drawH * (secretPlayerImg.naturalWidth / secretPlayerImg.naturalHeight);
                ctx.shadowBlur = 40 + Math.random() * 40;
                ctx.shadowColor = "#00ffff";
                ctx.drawImage(secretPlayerImg, -drawW*0.1+jitterX, (canvas.height-drawH)/2+jitterY, drawW, drawH);
            } else {
                ctx.fillStyle = "rgba(41, 182, 246, 0.5)";
                ctx.fillRect(0, 0, canvas.width * 0.15, canvas.height);
            }

            if (frames % 8 < 4) {
                drawLightning(canvas.width*0.1, canvas.height*0.5);
                drawLightning(canvas.width*0.2, canvas.height*0.2);
            }
            ctx.restore();

            drawGoose(player.x, player.y, player.rotation, frames, isClashing, secretMode.active);
        } else {
            drawGoose(goose.x, goose.y, 0, frames, isClashing, false);

            ctx.save();
            ctx.translate(player.x+player.width/2, player.y+player.height/2);
            ctx.rotate(player.rotation);

            if (playerImg.complete && playerImg.naturalWidth > 0) {
                const aspect = playerImg.naturalWidth / playerImg.naturalHeight || 1;
                const drawW = player.width * 1.5;
                const drawH = drawW / aspect;
                ctx.drawImage(playerImg, -drawW/2, -drawH/2, drawW, drawH);
            } else {
                ctx.fillStyle = "#29b6f6";
                ctx.fillRect(-20, -20, 40, 40);
                ctx.strokeStyle="black";
                ctx.strokeRect(-20,-20,40,40);
            }
            ctx.restore();
        }

        if (isClashing) drawClashClouds(1, clashCloudParticles);

        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            let radius = Math.max(0, p.life / 5);
            ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
            ctx.fill();
        });

        scoreFloater.forEach(f => drawFloater(f));

        if (secretMode.active) {
            ctx.font = "bold 40px 'Comic Sans MS'";
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(Math.sin(frames*0.1))})`;
            ctx.textAlign = "center";
            ctx.fillText("SUPERCHARGE!", canvas.width/2, 100);
        }
    }

    function loop() {
        if (!isPaused) {
            try {
                if (isPlaying || isClashing) {
                    update();
                    draw();
                } else if (isGameOver) {
                    draw();
                }
            } catch (error) {
                console.error("Game Loop Error:", error);
                if (secretMode.active) {
                    secretMode.active = false;
                    document.getElementById('game-stage').classList.remove('blueprint-mode');
                }
            }
        }

        requestAnimationFrame(loop);
    }

    // ==========================================
    // --- EVENTS ---
    // ==========================================

    document.getElementById('change-user-btn').addEventListener('click', window.changeUser);

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);
    window.addEventListener('resize', resize);
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') { if(isPaused) togglePause(); else jump(); }
        if (e.code === 'Tab') { e.preventDefault(); togglePause(); }
    });
    canvas.addEventListener('mousedown', jump);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, { passive: false });

    function togglePause() {
        if (!isPlaying || isGameOver || isClashing) return;
        isPaused = !isPaused;
        const overlay = document.getElementById('pause-overlay');
        isPaused ? overlay.classList.add('active') : overlay.classList.remove('active');
        if(!isPaused && AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
    }

    document.getElementById('pause-overlay').addEventListener('click', togglePause);

    // --- ON LOAD ---
    window.addEventListener('load', function() {
        resize();
        updateUserDisplay();

        const startBtn = document.getElementById('start-btn');
        const loadingIndicator = document.getElementById('loading');
        startBtn.disabled = true;
        loadingIndicator.innerText = "Loading Sounds...";

        AudioSys.init().then(() => {
            loadingIndicator.style.display = 'none';
            startBtn.disabled = false;
            startBtn.innerText = "Start Flying";

            window.addEventListener('click', function ms() {
                if(AudioSys.ctx && AudioSys.ctx.state==='suspended') AudioSys.ctx.resume();
                if(!AudioSys.isPlaying) AudioSys.playTrack('start_screen');
            }, { once: true });
        });

        const vs = document.getElementById('volume-slider');
        if(vs) vs.addEventListener('input', (e) => { e.stopPropagation(); AudioSys.setVolume(e.target.value); if(AudioSys.ctx && AudioSys.ctx.state==='suspended')AudioSys.ctx.resume(); });
    });

    // Mobile landscape fullscreen helper (added)
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function autoFullscreenOnLandscape() {
        if (!isMobileDevice()) return;
        if (window.orientation === 90 || window.orientation === -90) {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(()=>{});
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            }
        }
    }
    window.addEventListener('orientationchange', autoFullscreenOnLandscape);

    // Mute control wiring
    document.getElementById('mute-btn').addEventListener('click', () => { AudioSys.toggleMute(); });

    // initial resize
    resize();
</script>
</body>
</html>
