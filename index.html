<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Silly Goose Chase</title>
    
    <!-- Google Fonts: Barriecito -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Barriecito&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
           /* New Background: A subtle blueprint/grid style */
            background-color: #f0f0f0;
            background-image: 
                linear-gradient(#e0e0e0 1px, transparent 1px),
                linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
            background-size: 40px 40px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            position: relative;
            z-index: 0;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        /* Main Title Styling */
        #main-title {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-family: 'Barriecito', cursive;
            font-size: 4rem; 
            color: #d32f2f;
            text-shadow: 3px 3px 0px #000;
            margin: 0;
            z-index: 30;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .hidden { display: none !important; }

     .message-box {
            /* 1. Hide by default */
            display: none; 
            
            /* 2. CRITICAL FIX: Allow clicking on this box! */
            pointer-events: auto; 
            
            /* 3. Flex Layout */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            
            /* 4. Visuals */
            background: #ffffff;
            border: 8px solid #000;
            border-radius: 25px;
            padding: 40px;
            text-align: center;
            box-shadow: 15px 15px 0px rgba(0,0,0,0.2);
            
            /* 5. Sizing & Position */
            min-width: 300px;
            max-width: 500px;
            position: relative; 
            margin: auto; 
            z-index: 20;
            
            font-size: 1.5rem;
            font-family: 'Barriecito', cursive;
        }
        
        /* NEW RULE: Use this to show the box */
        .message-box.active {
            display: flex !important;
        }
        
    #start-rev-img {
            position: absolute;
            
            /* THE FIX: Pull him 10% past the edge to hide the gap */
            /* If he is still too far left, change this to -15% or -20% */
            right: -15%; 
            
            /* Height & Floor Anchor */
            bottom: -15vh; 
            height: 85vh; 
            
            /* Size handling */
            width: auto;
            max-width: none; 
            
            object-fit: contain;
            object-position: bottom right; 
            
            pointer-events: none;
            z-index: 1; 
            
            /* DOUBLE CHECK: Make sure this transform line is DELETED */
            /* transform: scaleX(-1); */ 
        }
        
        #start-goose-img {
            position: absolute;
            left: 0;
            
            /* Sink it slightly */
            bottom: -2vh;
            
            /* Make it a bit bigger */
            height: 55vh; 
            
            width: auto;
            max-width: none;
            
            object-fit: contain;
            object-position: bottom left; 
            
            pointer-events: none;
            z-index: 1; 
        }
        
        .spin-in {
            display: block !important;
            animation: spinIn 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes spinIn {
            0% { transform: scale(0) rotate(-1080deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        h1 {
            margin: 0 0 10px 0;
            color: #d32f2f;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 2rem;
            text-shadow: 2px 2px 0px #000;
        }
        p {
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 15px;
        }
        button {
            background: #ffeb3b;
            border: 3px solid #000;
            padding: 10px 20px;
            font-size: 1.2rem;
            font-family: inherit;
            cursor: pointer;
            border-radius: 8px;
            transition: transform 0.1s;
            margin: 5px;
        }
        button:active {
            transform: scale(0.95);
        }
        
        #score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2rem;
            color: #333;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 2px 2px 0px #fff;
            transition: color 0.5s;
        }
        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000;
            flex-direction: column;
            padding: 20px;
            text-align: center;
        }
        #loading.error {
            background: #ffebee;
            color: #d32f2f;
        }
        
        /* Secret Level Styles */
        body.blueprint-mode {
            background-color: #0d47a1; /* Dark Blue */
        }
        body.blueprint-mode #score-display {
            color: #fff;
            text-shadow: 0 0 10px #4fc3f7;
        }
        
        /* Audio Controls */
        #audio-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            height: 40px;
            background: rgba(255,255,255,0.8);
            border: 2px solid #333;
            border-radius: 20px;
            display: flex;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
            transition: width 0.3s ease;
            width: 40px; /* Collapsed width */
            overflow: hidden;
        }
        
        #audio-controls:hover {
            width: 160px; /* Expanded width to show slider */
        }

        #mute-btn {
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            user-select: none;
        }

        #volume-slider {
            width: 100px;
            margin-left: 5px;
            margin-right: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        #audio-controls:hover #volume-slider {
            opacity: 1;
            pointer-events: auto;
        }

        /* Rotate Message */
        #rotate-message {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #222;
            color: #fff;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        @media only screen and (orientation: portrait) and (max-width: 768px) {
            #rotate-message { display: flex; }
            #ui-layer { display: none; }
        }
    </style>
</head>
<body>

<div id="rotate-message">
    <div style="font-size: 50px; margin-bottom: 20px;">üîÑ</div>
    <h1>Please Rotate Device</h1>
    <p>This game is best played in Landscape mode!</p>
</div>

<canvas id="gameCanvas"></canvas>

<div id="score-display">Score: 0</div>

<div id="audio-controls">
    <div id="mute-btn">üîä</div>
    <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="0.5">
</div>

<div id="ui-layer">
    <!-- Main Title -->
    <h1 id="main-title">Silly Goose Chase</h1>

    <!-- Start Screen UI -->
    <div id="start-screen" class="message-box active">
        <p id="instruction-text">Tap repeatedly to fly!</p>
        <button id="start-btn" onclick="startGame()">Start Flying</button>
    </div>
    
    <!-- START SCREEN IMAGES (Static Config) -->
    <!-- These images are independent of the canvas game loop -->
    <img id="start-rev-img" alt="Rev">
    <img id="start-goose-img" alt="Goose">
    
    <div id="game-over-screen" class="message-box">
        <h1>Silly Goose!</h1>
        <p>Your Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Try Again</button>
    </div>
</div>

<div id="loading">Loading...</div>

<!-- FAILSAFE SCRIPT -->
<script>
    window.addEventListener('load', function() {
        setTimeout(function() {
            var loader = document.getElementById('loading');
            if (loader) loader.style.display = 'none';
        }, 500);
    });
    
    window.onerror = function(msg, url, lineNo, columnNo, error) {
        var loader = document.getElementById('loading');
        if(loader) {
            loader.className = 'error';
            loader.innerHTML = "<strong>‚ö†Ô∏è Game Crashed!</strong><br><br>" + msg + "<br><br>Check Line: " + lineNo;
            loader.style.display = 'flex';
        }
        return false;
    };
</script>

<script>
    // =========================================================================
    //  --- 1. ASSET CONFIGURATION ---
    //  Paste your strings/paths inside the quotes below.
    // =========================================================================
    
    // In-Game Player Character (The one you fly) - SVG Code or Image Path
    const PERMANENT_PLAYER_SVG = `sprite.png`; 

    // Start Screen Images (File paths or Base64)
    // Left side image
    const START_SCREEN_GOOSE_SRC = `goose.png`; 
    // Right side image (Defaults to 'NewRevBigEyes...' if blank)
    const START_SCREEN_REV_SRC = `rev.png?v=2`; 

    // Audio Files (File paths or Base64)
    const AUDIO_FILES = {
        jump: "jump.wav",
        coin1: "coin1.wav",
        coin2: "coin2.wav",
        powerup: "",
        music_main: "music_main.wav",
        music_clash: "music_clash.wav",
        music_start: "music.start.wav"
    };

    // --- 2. GAME CONSTANTS & GLOBALS ---
    
    const CONFIG = {
        gravity: 0.2, 
        jumpStrength: -6.5,
        gameSpeed: 3.3, 
        spawnRate: 240, 
        gapSize: 220,   
        playerScale: 0.15,
        doodleWobbleSpeed: 0.1,
        clashDuration: 180,
        batterySpawnChance: 0.005, 
        coinChancePerGap: 0.1
    };

    // Canvas Globals
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // State Globals
    let frames = 0;
    let score = 0;
    let isGameOver = false;
    let isPlaying = false;
    let isClashing = false;
    let clashTimer = 0;
    let doodleTime = 0;
    
    // Entities
    const secretMode = { active: false, timer: 0, maxDuration: 300 };
    const battery = { active: false, x: 0, y: 0, width: 30, height: 50, wobble: 0 };
    const player = { x: 0, y: 0, width: 50, height: 50, velocity: 0, rotation: 0, baseX: 0, baseY: 0 };
    const goose = { x: -100, y: 0, targetX: 50, frame: 0 };
    
    let obstacles = [];
    let particles = [];
    let clashCloudParticles = [];
    let bgElements = [];
    let coins = [];
    let scoreFloater = [];

    // --- 3. ASSET LOADING & SETUP ---

// --- 3. ASSET LOADING & SETUP ---

    // 1. The Player Character (Master Loader)
    const playerImg = new Image();
    
    // Add a "Detective" to tell us if the file is missing
    playerImg.onerror = function() {
        console.error("Could not load sprite.png! Checking path...");
        // Use the fallback blue box if it fails, but don't crash
        playerImg.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjMjliNmY2Ii8+PC9zdmc+";
    };
    
    // Set the source (Trim removes any accidental spaces)
    if (PERMANENT_PLAYER_SVG) {
        playerImg.src = PERMANENT_PLAYER_SVG.trim();
    }

    // 2. Start Screen Characters
    const startRevImg = new Image();
    if (START_SCREEN_REV_SRC) startRevImg.src = START_SCREEN_REV_SRC.trim();

    const startGooseImg = new Image();
    if (START_SCREEN_GOOSE_SRC) startGooseImg.src = START_SCREEN_GOOSE_SRC.trim();

    // 3. HTML Overlay Elements (Keeps the start screen working)
    const revImg = document.getElementById('start-rev-img');
    const gooseImg = document.getElementById('start-goose-img');
    
    if (START_SCREEN_REV_SRC && START_SCREEN_REV_SRC.length > 1) {
        if (revImg) {
            revImg.src = START_SCREEN_REV_SRC;
            revImg.style.display = 'block';
        }
    }
    if (START_SCREEN_GOOSE_SRC && START_SCREEN_GOOSE_SRC.length > 1) {
        if (gooseImg) {
            gooseImg.src = START_SCREEN_GOOSE_SRC;
            gooseImg.style.display = 'block';
        }
    }

    // 4. Audio Setup
    const custom_audio = {}; 

    for (let key in AUDIO_FILES) {
        if (AUDIO_FILES[key] && AUDIO_FILES[key].length > 0) {
            custom_audio[key] = new Audio(AUDIO_FILES[key]);
            custom_audio[key].volume = 0.4; 
        }
    }

    // --- 4. AUDIO ENGINE ---
    const AudioSys = {
        ctx: null, isPlaying: false, isMuted: false, tempo: 1.45,
        masterVolume: 0.5, customBuffers: {}, activeSource: null, bgMusicGainNode: null,
        nextNoteTime: 0, noteIndex: 0, currentTrack: 'main',

        N: {
            G2: 98.00, Gs2: 103.83, A2: 110.00, As2: 116.54, B2: 123.47,
            C3: 130.81, Cs3: 138.59, D3: 146.83, Ds3: 155.56, E3: 164.81, F3: 174.61, Fs3: 185.00, G3: 196.00, Gs3: 207.65, A3: 220.00, As3: 233.08, B3: 246.94,
            C4: 261.63, Cs4: 277.18, D4: 293.66, Ds4: 311.13, E4: 329.63, F4: 349.23, Fs4: 369.99, G4: 392.00, Gs4: 415.30, A4: 440.00, As4: 466.16, B4: 493.88,
            C5: 523.25, Cs5: 554.37, D5: 587.33, Ds5: 622.25, E5: 659.25, F5: 698.46, Fs5: 739.99, G5: 783.99, Gs5: 830.61, A5: 880.00,
            Eb4: 311.13, Bb4: 466.16, Eb5: 622.25 
        },
        tracks: {
            main: [
                {f: 'A4', d: 0.15}, {f: 'C5', d: 0.15}, {f: 'E5', d: 0.15}, {f: 'A5', d: 0.15}, 
                {f: 'G5', d: 0.15}, {f: 'E5', d: 0.15}, {f: 'C5', d: 0.15}, {f: 'G4', d: 0.15},
                {f: 'A4', d: 0.15}, {f: 'C5', d: 0.15}, {f: 'D5', d: 0.15}, {f: 'Eb5', d: 0.15}, 
                {f: 'E5', d: 0.15}, {f: 'G5', d: 0.15}, {f: 'E5', d: 0.15}, {f: 'C5', d: 0.15},
                {f: 'A5', d: 0.15}, {f: 'Gs5', d: 0.15}, {f: 'G5', d: 0.15}, {f: 'Fs5', d: 0.15}, 
                {f: 'F5', d: 0.15}, {f: 'E5', d: 0.15}, {f: 'Eb5', d: 0.15}, {f: 'D5', d: 0.15},
                {f: 'C5', d: 0.15}, {f: 'A4', d: 0.15}, {f: 'C5', d: 0.15}, {f: 'E5', d: 0.15}, 
                {f: 'A5', d: 0.15}, {f: 0, d: 0.15}, {f: 'A4', d: 0.15}, {f: 0, d: 0.15}
            ],
            clash: [
                {f: 'C4', d: 0.1}, {f: 'Cs4', d: 0.1}, {f: 'D4', d: 0.1}, {f: 'Eb4', d: 0.1},
                {f: 'E4', d: 0.1}, {f: 'F4', d: 0.1}, {f: 'Fs4', d: 0.1}, {f: 'G4', d: 0.1},
                {f: 'G4', d: 0.1}, {f: 'Fs4', d: 0.1}, {f: 'F4', d: 0.1}, {f: 'E4', d: 0.1},
                {f: 'Eb4', d: 0.1}, {f: 'D4', d: 0.1}, {f: 'Cs4', d: 0.1}, {f: 'C4', d: 0.1},
                {f: 'C5', d: 0.1}, {f: 'B4', d: 0.1}, {f: 'Bb4', d: 0.1}, {f: 'A4', d: 0.1},
                {f: 'Gs4', d: 0.1}, {f: 'G4', d: 0.1}, {f: 'Fs4', d: 0.1}, {f: 'F4', d: 0.1},
                {f: 'E4', d: 0.1}, {f: 'Eb4', d: 0.1}, {f: 'D4', d: 0.1}, {f: 'Cs4', d: 0.1},
                {f: 'C4', d: 0.1}, {f: 0, d: 0.1}, {f: 'G3', d: 0.1}, {f: 'C3', d: 0.2}
            ]
        },

        init: function() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.loadCustomSounds();
            }
        },

        loadCustomSounds: function() {
            const loadBuffer = (key, rawData) => {
                if (!rawData || rawData.length < 5) return;
                
                // If it's a file path
                if (!rawData.startsWith('data:')) {
                    fetch(rawData)
                        .then(r => r.arrayBuffer())
                        .then(b => this.ctx.decodeAudioData(b))
                        .then(d => { this.customBuffers[key] = d; })
                        .catch(e => console.warn(key + " load failed"));
                    return;
                }
                
                // If it's base64
                let clean = rawData.replace(/\s/g, '');
                if (clean.includes(',')) clean = clean.split(',')[1];
                try {
                    const byteStr = window.atob(clean);
                    const len = byteStr.length;
                    const bytes = new Uint8Array(len);
                    for(let i=0; i<len; i++) bytes[i] = byteStr.charCodeAt(i);
                    this.ctx.decodeAudioData(bytes.buffer, (b) => { this.customBuffers[key] = b; });
                } catch(e) { console.warn(key + " decode error"); }
            };

            loadBuffer('jump', AUDIO_FILES.jump);
            loadBuffer('coin1', AUDIO_FILES.coin1);
            loadBuffer('coin2', AUDIO_FILES.coin2);
            loadBuffer('powerup', AUDIO_FILES.powerup);
            loadBuffer('main', AUDIO_FILES.music_main);
            loadBuffer('clash', AUDIO_FILES.music_clash);
            loadBuffer('music_start', AUDIO_FILES.music_start);
        },

        toggleMute: function() {
            this.isMuted = !this.isMuted;
            document.getElementById('mute-btn').innerText = this.isMuted ? "üîá" : "üîä";
            if(this.ctx) this.isMuted ? this.ctx.suspend() : this.ctx.resume();
        },
        
        setVolume: function(val) {
            this.masterVolume = parseFloat(val);
            if (this.masterVolume > 0 && this.isMuted) this.toggleMute();
            if (this.bgMusicGainNode) this.bgMusicGainNode.gain.setValueAtTime(0.4 * this.masterVolume, this.ctx.currentTime);
        },

        playTone: function(freq, duration, type = 'triangle', vol = 0.1) {
            if (this.isMuted || !this.ctx) return;
            if (!Number.isFinite(freq) || freq <= 0) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(vol * this.masterVolume, this.ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + duration);
        },

        playTrack: function(trackName) {
            if (this.activeSource) { try{this.activeSource.stop();}catch(e){}; this.activeSource=null; }
            this.currentTrack = trackName;
            this.noteIndex = 0;
            this.isPlaying = true;
            
            let bufferKey = trackName;
            if(trackName === 'start_screen') bufferKey = 'music_start';

            if ((trackName === 'main' && this.customBuffers['main']) || 
                (trackName === 'clash' && this.customBuffers['clash']) ||
                (trackName === 'start_screen' && this.customBuffers['music_start'])) {
                
                const buffer = this.customBuffers[bufferKey];
                if (this.isMuted || !this.ctx) return;
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.loop = true;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.4 * this.masterVolume;
                source.connect(gain); gain.connect(this.ctx.destination);
                source.start();
                this.activeSource = source;
                this.bgMusicGainNode = gain;
            } else {
                if (this.ctx) this.nextNoteTime = this.ctx.currentTime;
            }
        },

        stopMusic: function() {
            this.isPlaying = false;
            if (this.activeSource) { try{this.activeSource.stop();}catch(e){}; this.activeSource=null; }
        },
        
        update: function() {
            if (this.isPlaying && !this.activeSource) this.scheduleNote();
        },

        scheduleNote: function() {
            if (this.isMuted || !this.ctx || !this.isPlaying) return;
            const track = this.tracks[this.currentTrack];
            if (!track) return;
            while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                const noteData = track[this.noteIndex];
                let freq = typeof noteData.f === 'string' ? this.N[noteData.f] : noteData.f;
                if (freq > 0) this.playTone(freq, noteData.d * (0.9/this.tempo), 'square', 0.05);
                
                // Bass logic for synth fallback
                if (this.currentTrack === 'main' && this.noteIndex % 2 === 0) {
                     let bass = this.N.A2;
                     if(this.noteIndex % 8 >= 2) bass = this.N.C3;
                     if(this.noteIndex % 8 >= 4) bass = this.N.E3;
                     if(this.noteIndex % 8 >= 6) bass = this.N.G3;
                     this.playTone(bass, 0.1/this.tempo, 'sawtooth', 0.1);
                }

                this.nextNoteTime += noteData.d / this.tempo;
                this.noteIndex++;
                if (this.noteIndex >= track.length) this.noteIndex = 0;
            }
        },

        playSound: function(name) {
            if (this.isMuted || !this.ctx) return;
            
            let bufferKey = name;
            if (name === 'coin') {
                if (this.customBuffers['coin1'] && this.customBuffers['coin2']) 
                    bufferKey = Math.random() > 0.5 ? 'coin1' : 'coin2';
                else if (this.customBuffers['coin1']) bufferKey = 'coin1';
            }

            if (this.customBuffers[bufferKey]) {
                const source = this.ctx.createBufferSource();
                source.buffer = this.customBuffers[bufferKey];
                const gain = this.ctx.createGain();
                gain.gain.value = 1.0 * this.masterVolume;
                source.connect(gain); gain.connect(this.ctx.destination);
                source.start();
                return;
            }

            // Fallbacks
            if (name === 'jump') this.playTone(300, 0.15, 'triangle', 0.1);
            else if (name === 'coin') { this.playTone(1200, 0.1, 'sine', 0.1); setTimeout(()=>this.playTone(1800, 0.15, 'sine', 0.1), 80); }
            else if (name === 'powerup') { 
                this.playTone(this.N.A4, 0.1, 'sawtooth', 0.1); 
                setTimeout(()=>this.playTone(this.N.Cs5, 0.1, 'sawtooth', 0.1), 80);
                setTimeout(()=>this.playTone(this.N.E5, 0.3, 'sawtooth', 0.1), 160);
            }
        }
    };

    // --- DRAWING FUNCTIONS ---

    function drawWobblyLine(x1, y1, x2, y2, color, thickness) {
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = thickness; ctx.lineCap = 'round';
        const segments = Math.max(2, Math.floor(Math.abs(x2 - x1 + y2 - y1) / 20));
        const dx = (x2 - x1) / segments; const dy = (y2 - y1) / segments;
        ctx.moveTo(x1, y1);
        for (let i = 1; i <= segments; i++) {
            const offsetX = Math.sin(doodleTime + i) * 2; const offsetY = Math.cos(doodleTime + i * 2) * 2;
            ctx.lineTo(x1 + dx * i + offsetX, y1 + dy * i + offsetY);
        }
        ctx.stroke();
    }

    function drawDoodleRect(x, y, w, h, fillColor, strokeColor) {
        ctx.fillStyle = fillColor;
        ctx.beginPath(); ctx.moveTo(x + 2, y + 2); ctx.lineTo(x + w - 2, y + 5);
        ctx.lineTo(x + w - 5, y + h - 2); ctx.lineTo(x + 3, y + h - 5); ctx.closePath(); ctx.fill();
        drawWobblyLine(x, y, x + w, y, strokeColor, 3); drawWobblyLine(x + w, y, x + w, y + h, strokeColor, 3);
        drawWobblyLine(x + w, y + h, x, y + h, strokeColor, 3); drawWobblyLine(x, y + h, x, y, strokeColor, 3);
        ctx.beginPath(); ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 2;
        for(let i=10; i<w; i+=15) { ctx.moveTo(x + i, y + 5); ctx.lineTo(x + i - 5, y + h - 5); } ctx.stroke();
    }

    function drawClouds(frames, isBlueprint) {
        ctx.fillStyle = isBlueprint ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.5)"; 
        ctx.beginPath();
        const t = frames * 0.002;
        for(let i = 0; i < 5; i++) {
             let cx = ((i * 300) + t * 100) % (canvas.width + 200) - 100;
             let cy = 50 + Math.sin(i + t) * 30;
             ctx.arc(cx, cy, 40, 0, Math.PI * 2);
             ctx.arc(cx + 30, cy - 10, 50, 0, Math.PI * 2);
             ctx.arc(cx + 60, cy, 40, 0, Math.PI * 2);
        }
        ctx.fill();
    }

    function drawPaperBackground() {
        ctx.beginPath(); ctx.strokeStyle = "rgba(173, 216, 230, 0.5)"; ctx.lineWidth = 1;
        const gridSize = 40;
        for (let x = 0; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
        for (let y = 0; y < canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
        ctx.stroke();
        ctx.beginPath(); ctx.strokeStyle = "rgba(255, 182, 193, 0.8)"; ctx.lineWidth = 2;
        ctx.moveTo(60, 0); ctx.lineTo(60, canvas.height); ctx.stroke();
    }
    
    function drawBlueprintBackground() {
        ctx.beginPath(); ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"; ctx.lineWidth = 1;
        const gridSize = 40;
        for (let x = -canvas.height; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x + canvas.height, canvas.height); }
        ctx.stroke();
    }

    function drawBattery(x, y, frames) {
        drawDoodleRect(x, y, 30, 50, "#00e676", "#000"); 
        ctx.fillStyle = "#888";
        ctx.fillRect(x + 7, y - 6, 16, 6);
        ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.strokeRect(x + 7, y - 6, 16, 6);
        if (frames % 20 < 10) {
            ctx.fillStyle = "yellow";
            ctx.beginPath(); ctx.arc(x - 5, y - 5, 5, 0, Math.PI*2); ctx.fill();
        }
    }

    function drawSpaceDoodle(el) {
        ctx.save();
        ctx.translate(el.x, el.y);
        ctx.rotate(el.rotation);
        ctx.strokeStyle = el.color;
        ctx.fillStyle = el.color.replace('0.2)', '0.05)'); 
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        
        if (el.type === 'sun') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            const rays = 10;
            for(let i=0; i<rays; i++) {
                const angle = (i / rays) * Math.PI * 2;
                ctx.moveTo(Math.cos(angle)*(el.size/2+5), Math.sin(angle)*(el.size/2+5));
                ctx.lineTo(Math.cos(angle)*(el.size/2+25), Math.sin(angle)*(el.size/2+25));
            }
            ctx.stroke();
        } else if (el.type === 'moon') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(-el.size/6, -el.size/6, el.size/6, 0, Math.PI*2); ctx.stroke();
        } else if (el.type === 'earth') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-el.size/3, -el.size/4);
            ctx.quadraticCurveTo(0, -el.size/2, el.size/3, -el.size/4);
            ctx.stroke();
        } else if (el.type === 'comet') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/3, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-el.size/3, 0); ctx.lineTo(-el.size*1.5, -el.size/3); ctx.stroke();
        } else if (el.type === 'asteroid') {
            ctx.beginPath(); const points = 8;
            for(let i=0; i<=points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const r = el.size/2 + (Math.sin(i * 345) * 5); 
                i===0 ? ctx.moveTo(Math.cos(angle)*r, Math.sin(angle)*r) : ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
            }
            ctx.stroke();
        } else if (el.type === 'planet') {
            ctx.beginPath(); ctx.arc(0, 0, el.size/2, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(0, 0, el.size/1.2, el.size/4, Math.PI/-6, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
    }

    function drawCoin(c, frames) {
        ctx.save();
        ctx.translate(c.x, c.y);
        const scale = 1 + Math.sin(frames * 0.1 + c.wobbleOffset) * 0.1;
        ctx.scale(scale, scale);
        
        ctx.fillStyle = c.color;
        ctx.beginPath(); ctx.arc(0, 0, c.radius, 0, Math.PI*2); ctx.fill();
        drawWobblyLine(-c.radius, -c.radius*0.8, c.radius, -c.radius*0.8, "#000", 2); 
        ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 0, c.radius, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, c.radius * 0.7, 0, Math.PI*2); ctx.stroke();
        
        ctx.fillStyle = "#fff"; ctx.font = `bold ${c.radius}px 'Comic Sans MS'`;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(c.value, 0, 2);
        ctx.restore();
    }

    function drawFloater(f) {
        ctx.save();
        ctx.globalAlpha = f.life / 60;
        ctx.fillStyle = f.color;
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
        ctx.font = "bold 24px 'Comic Sans MS'";
        ctx.textAlign = "center";
        ctx.fillText(f.text, f.x, f.y);
        ctx.strokeText(f.text, f.x, f.y);
        ctx.restore();
    }

    function drawClashClouds(layer, clashCloudParticles) {
        clashCloudParticles.forEach(p => {
            if (p.layer !== layer) return;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = (layer === 1) ? p.alpha * 0.6 : p.alpha;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#888";
            ctx.lineWidth = 1;
            ctx.stroke();
        });
        ctx.globalAlpha = 1.0;
    }

    function drawLightning(centerX, centerY) {
        ctx.beginPath();
        ctx.strokeStyle = Math.random() > 0.5 ? "#00ffff" : "#ffffff";
        ctx.lineWidth = 3 + Math.random() * 3;
        let lx = centerX - 20 + (Math.random() - 0.5) * 60;
        let ly = centerY - 200; 
        ctx.moveTo(lx, ly);
        for(let i=0; i<12; i++) {
            lx += (Math.random() - 0.5) * 60;
            ly += Math.random() * 60;
            ctx.lineTo(lx, ly);
        }
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#00ffff";
        ctx.stroke();
        ctx.shadowBlur = 0; 
    }

    function drawGoose(x, y, rotation, frames, isClashing, secretModeActive) {
        const wiggle = Math.sin(frames * 0.2) * 5;
        ctx.save(); 
        ctx.translate(x, y);
        
        // --- NEW LINE: Make the Goose 30% larger! ---
        ctx.scale(1.3, 1.3); 
        
        if (rotation) ctx.rotate(rotation); 
        // ... rest of the function stays the same ...
        
        ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.ellipse(0, 0, 30, 20, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(20, -5); ctx.quadraticCurveTo(40, -15, 45 + wiggle/2, -30); ctx.stroke();
        ctx.beginPath(); ctx.arc(45 + wiggle/2, -30, 10, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "orange"; ctx.beginPath(); ctx.moveTo(53 + wiggle/2, -33); ctx.lineTo(65 + wiggle/2, -28); ctx.lineTo(53 + wiggle/2, -25); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(48 + wiggle/2, -32, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(45 + wiggle/2, -36); ctx.lineTo(52 + wiggle/2, -34); ctx.stroke();
        ctx.fillStyle = "white"; const wingY = Math.sin(frames * 0.5) * 15;
        ctx.beginPath(); ctx.moveTo(0, -5); ctx.quadraticCurveTo(10, -25 + wingY, -10, -10 + wingY); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = "orange"; ctx.beginPath(); ctx.moveTo(-5, 15); ctx.lineTo(-10 + wiggle, 25);
        ctx.moveTo(5, 15); ctx.lineTo(10 + wiggle, 28); ctx.stroke();
        
        if (!isClashing) {
            if (!secretModeActive && frames % 100 < 40 && !rotation) {
                ctx.font = "bold 20px 'Comic Sans MS'"; ctx.fillStyle = "red"; ctx.fillText("HONK!", 50, -50);
            }
            else if (secretModeActive) {
                if (frames % 10 < 7) { 
                    ctx.save();
                    ctx.translate((Math.random()-0.5)*8, (Math.random()-0.5)*8);
                    const size = 20 + Math.random() * 10;
                    ctx.font = `bold ${size}px 'Comic Sans MS'`; 
                    ctx.fillStyle = Math.random() > 0.5 ? "red" : "#ff3333"; 
                    ctx.fillText("HONK!!", 50, -60);
                    ctx.restore();
                }
            }
        }
        ctx.restore();
    }

    // --- GAME LOGIC ---

    function createParticle(x, y, type) {
        let color = "rgba(0,0,0,0.2)";
        if (type === 'spark') color = "#4fc3f7"; 
        
        particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 30, type: type, color: color });
    }

    function createCoin(spawnX, spawnY) {
        const rand = Math.random();
        let value = 5, color = "#cd7f32", radius = 15;
        if (rand > 0.98) { value = 100; color = "#e91e63"; radius = 25; } 
        else if (rand > 0.93) { value = 50; color = "#9c27b0"; radius = 22; } 
        else if (rand > 0.75) { value = 20; color = "#2196f3"; radius = 20; } 
        else if (rand > 0.45) { value = 10; color = "#c0c0c0"; radius = 18; } 
        const safeY = Math.max(50, Math.min(canvas.height - 50, spawnY));
        coins.push({ x: spawnX, y: safeY, value: value, color: color, radius: radius, wobbleOffset: Math.random() * Math.PI * 2 });
    }

    function createBgElement(xOffset) {
        const types = ['asteroid', 'planet', 'sun', 'moon', 'earth', 'comet'];
        const type = types[Math.floor(Math.random() * types.length)];
        let size = 40 + Math.random() * 40;
        if (type === 'planet') size = 70 + Math.random() * 40;
        if (type === 'sun') size = 90 + Math.random() * 30;
        if (type === 'earth') size = 65 + Math.random() * 20;
        if (type === 'moon') size = 40 + Math.random() * 20;
        if (type === 'comet') size = 30 + Math.random() * 15;

        bgElements.push({
            x: xOffset, y: Math.random() * canvas.height, type: type, size: size,
            speedFactor: 0.1 + Math.random() * 0.4, rotation: Math.random() * Math.PI * 2,
            color: `rgba(100, 116, 139, ${0.1 + Math.random() * 0.15})`
        });
    }

    function createObstacle() {
        const minHeight = 50;
        const maxHeight = canvas.height - CONFIG.gapSize - minHeight;
        const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight);
        obstacles.push({
            x: canvas.width, topHeight: topHeight, bottomY: topHeight + CONFIG.gapSize,
            width: 70, passed: false, colorIndex: Math.floor(Math.random() * 3)
        });
        if (Math.random() < CONFIG.coinChancePerGap) {
            const distanceToNext = CONFIG.spawnRate * CONFIG.gameSpeed;
            const coinX = canvas.width + (distanceToNext / 2) + 35; 
            const gapCenterY = topHeight + (CONFIG.gapSize / 2);
            const coinY = gapCenterY + (Math.random() - 0.5) * 100;
            createCoin(coinX, coinY);
        }
    }

    function spawnBattery() {
        if (!battery.active && !secretMode.active) {
            battery.active = true;
            battery.x = canvas.width + 100;
            let safeY = canvas.height / 2;
            if (obstacles.length > 0) {
                const lastObs = obstacles[obstacles.length - 1];
                const gapCenter = lastObs.topHeight + (CONFIG.gapSize / 2);
                safeY = gapCenter;
            }
            battery.y = safeY + (Math.random() - 0.5) * 60;
            battery.y = Math.max(50, Math.min(canvas.height - 100, battery.y));
        }
    }

    // --- MAIN ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (!isPlaying && !isClashing && player) {
            player.baseX = canvas.width * 0.30;
            player.x = player.baseX;
            player.y = canvas.height / 2;
        }
    }

    function jump() {
        if (!isPlaying || isGameOver || isClashing) return;
        player.velocity = CONFIG.jumpStrength;
        createParticle(player.x, player.y + player.height, 'jump');
        if (frames % 10 === 0) AudioSys.playSound('jump');
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (secretMode.active) drawBlueprintBackground(); else drawPaperBackground();
        bgElements.forEach(el => drawSpaceDoodle(el));
        drawClouds(frames, secretMode.active);
        
        const colors = ["#ffcc80", "#a5d6a7", "#90caf9"]; 
        const strokes = ["#e65100", "#1b5e20", "#0d47a1"]; 

        obstacles.forEach(obs => {
            if (secretMode.active) {
                ctx.save(); ctx.globalAlpha = 0.3;
                drawDoodleRect(obs.x, 0, obs.width, obs.topHeight, "#4fc3f7", "#fff");
                drawDoodleRect(obs.x, obs.bottomY, obs.width, canvas.height - obs.bottomY, "#4fc3f7", "#fff");
                ctx.restore();
            } else {
                drawDoodleRect(obs.x, 0, obs.width, obs.topHeight, colors[obs.colorIndex], strokes[obs.colorIndex]);
                drawDoodleRect(obs.x, obs.bottomY, obs.width, canvas.height - obs.bottomY, colors[obs.colorIndex], strokes[obs.colorIndex]);
            }
        });

        if (battery.active) drawBattery(battery.x, battery.y + battery.wobble, frames);
        coins.forEach(c => drawCoin(c, frames));
        
        if (isClashing) drawClashClouds(0, clashCloudParticles);
        
        if (secretMode.active) {
            ctx.save();
            const jitterX = (Math.random() - 0.5) * 15;
            const jitterY = (Math.random() - 0.5) * 15;
            let drawH = canvas.height;
            let drawW = 100; 
            if (playerImg.complete && playerImg.naturalWidth > 0) {
                const aspect = playerImg.width / playerImg.height;
                drawW = drawH * aspect;
            }
            let imgX = -drawW * 0.3 + jitterX; 
            let imgY = 0 + jitterY; 

            ctx.shadowBlur = 40 + Math.random() * 40; ctx.shadowColor = "#00ffff"; 
            if (playerImg.complete && playerImg.naturalWidth > 0) {
                ctx.drawImage(playerImg, imgX, imgY, drawW, drawH);
                ctx.globalCompositeOperation = "screen"; ctx.globalAlpha = 0.5;
                ctx.drawImage(playerImg, imgX + 10, imgY + 5, drawW, drawH);
                ctx.drawImage(playerImg, imgX - 10, imgY - 5, drawW, drawH);
                ctx.globalCompositeOperation = "source-over"; ctx.globalAlpha = 1.0;
                
                const eyeY = imgY + drawH * 0.42; const eyeSize = drawW * 0.12; 
                ctx.shadowBlur = 50; ctx.shadowColor = "#00ffff"; ctx.fillStyle = "#e0ffff"; 
                ctx.beginPath(); ctx.arc(imgX + drawW * 0.48, eyeY, eyeSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(imgX + drawW * 0.70, eyeY, eyeSize, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#00ffff";
                ctx.beginPath(); ctx.arc(imgX + drawW * 0.48, eyeY, eyeSize * 0.5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(imgX + drawW * 0.70, eyeY, eyeSize * 0.5, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle = "#29b6f6"; ctx.fillRect(0, 0, canvas.width * 0.15, canvas.height);
            }
            
            if (frames % 8 < 4) {
                drawLightning(canvas.width * 0.1, canvas.height * 0.5);
                drawLightning(canvas.width * 0.2, canvas.height * 0.2);
            }
            ctx.restore();
            drawGoose(player.x, player.y, player.rotation, frames, isClashing, secretMode.active);
        } else {
            drawGoose(goose.x, goose.y, 0, frames, isClashing, false);
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.rotate(player.rotation);
            if (playerImg.complete && playerImg.naturalWidth > 0) {
                const aspect = playerImg.width / playerImg.height;
                const drawW = player.width * 1.5; const drawH = drawW / aspect;
                ctx.drawImage(playerImg, -drawW/2, -drawH/2, drawW, drawH);
            } else {
                 ctx.fillStyle = "#29b6f6"; ctx.fillRect(-20, -20, 40, 40);
                 ctx.strokeStyle = "black"; ctx.strokeRect(-20, -20, 40, 40);
            }
            ctx.restore();
        }

        if (isClashing) drawClashClouds(1, clashCloudParticles);
        
        particles.forEach(p => {
            ctx.fillStyle = p.color || "rgba(0,0,0,0.2)";
            ctx.beginPath(); ctx.arc(p.x, p.y, p.life / 5, 0, Math.PI * 2); ctx.fill();
        });
        
        scoreFloater.forEach(f => drawFloater(f));
        
        if (secretMode.active) {
            ctx.font = "bold 40px 'Comic Sans MS'";
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(Math.sin(frames * 0.1))})`;
            ctx.textAlign = "center";
            ctx.fillText("SUPERCHARGE!", canvas.width/2, 100);
        }
    }

    function update() {
        frames++;
        doodleTime += CONFIG.doodleWobbleSpeed;
        
        for (let i = bgElements.length - 1; i >= 0; i--) {
            let el = bgElements[i];
            el.x -= CONFIG.gameSpeed * el.speedFactor;
            if (el.x < -el.size * 2) {
                bgElements.splice(i, 1);
            }
        }
        if (frames % 120 === 0) createBgElement(canvas.width + 100);

        AudioSys.update();

        if (isClashing) { 
            clashTimer--;
            
            const centerX = player.baseX;
            const centerY = player.baseY;
            const fightGap = 50; 
            
            const gooseTargetX = centerX - fightGap;
            const playerTargetX = centerX + fightGap;
            
            goose.x += (gooseTargetX - goose.x) * 0.1;
            goose.y += (centerY - goose.y) * 0.1;
            player.x += (playerTargetX - player.x) * 0.1;
            
            const t = frames * 0.1; 
            const bobY = 20; const swayX = 10;
            
            goose.y = centerY + Math.sin(t) * bobY;
            goose.x = gooseTargetX + Math.cos(t) * swayX;
            
            player.y = centerY + Math.sin(t + Math.PI) * bobY;
            player.x = playerTargetX + Math.cos(t + Math.PI) * swayX;
            
            player.rotation = Math.sin(t) * 0.1; 

            if (frames % 2 === 0) { 
                clashCloudParticles.push({
                    x: centerX + (Math.random() - 0.5) * 80, 
                    y: centerY + (Math.random() - 0.5) * 60,
                    radius: 30, maxRadius: 90 + Math.random() * 40, 
                    growth: 1.0 + Math.random() * 0.5, alpha: 1.0, 
                    color: Math.random() > 0.5 ? '#fff' : '#f4f4f4',
                    layer: Math.random() > 0.95 ? 1 : 0 
                });
            }
            for (let i = clashCloudParticles.length - 1; i >= 0; i--) {
                let p = clashCloudParticles[i];
                p.radius += p.growth; p.alpha -= 0.015; 
                if (p.alpha <= 0) clashCloudParticles.splice(i, 1);
            }
           if (clashTimer <= 0) {
                AudioSys.stopMusic();
                isGameOver = true;
                isClashing = false;
                document.getElementById('final-score').innerText = score;
                
                // NEW: Show Game Over screen using the class
                const endScreen = document.getElementById('game-over-screen');
                endScreen.classList.add('active'); // Add class to show it
                endScreen.classList.add('spin-in');
            }
            return; 
        }

        if (secretMode.active) {
            secretMode.timer--;
            CONFIG.gameSpeed = 8; 
            if (frames % 10 === 0) {
                score++;
                document.getElementById('score-display').innerText = `Score: ${score}`;
            }
            if (secretMode.timer <= 0) {
                secretMode.active = false;
                AudioSys.tempo = 1.45; 
                document.body.classList.remove('blueprint-mode');
                createParticle(player.x, player.y, 'jump');
                player.x = canvas.width * 0.30;
                obstacles = obstacles.filter(obs => obs.x > canvas.width * 0.8);
                CONFIG.gameSpeed = 3.2;
            }
            if (frames % 40 === 0) {
                 createCoin(canvas.width + 100, Math.random() * canvas.height);
            }
        } else {
            if (score >= 30 && Math.random() < CONFIG.batterySpawnChance) {
                spawnBattery();
            }
        }

        if (battery.active) {
            battery.x -= CONFIG.gameSpeed;
            battery.wobble = Math.sin(frames * 0.1) * 5;
            if (
                player.x < battery.x + battery.width &&
                player.x + player.width > battery.x &&
                player.y < battery.y + battery.height &&
                player.y + player.height > battery.y
            ) {
                secretMode.active = true;
                secretMode.timer = secretMode.maxDuration;
                battery.active = false; 
                AudioSys.playSound('powerup');
                AudioSys.tempo = 1.6; 
                document.body.classList.add('blueprint-mode');
                player.x = canvas.width * 0.6;
                for(let i=0; i<30; i++) createParticle(player.x + 25, player.y + 25, 'spark');
            }
            if (battery.x < -100) battery.active = false;
        }

        player.velocity += CONFIG.gravity;
        player.y += player.velocity;
        player.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (player.velocity * 0.1)));

        if (player.y + player.height > canvas.height || player.y < 0) {
            if (!secretMode.active) {
                AudioSys.playTrack('clash');
                isPlaying = false; 
                isClashing = true; 
                clashTimer = CONFIG.clashDuration;
                player.baseY = player.y; 
            }
        }

        if (frames % CONFIG.spawnRate === 0) createObstacle();

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= CONFIG.gameSpeed;
            const padding = 10; 
            if (
                player.x + padding < obs.x + obs.width &&
                player.x + player.width - padding > obs.x &&
                (player.y + padding < obs.topHeight || player.y + player.height - padding > obs.bottomY)
            ) {
                if (!secretMode.active) {
                    AudioSys.playTrack('clash');
                    isPlaying = false; 
                    isClashing = true; 
                    clashTimer = CONFIG.clashDuration;
                    player.baseY = player.y; 
                }
            }

            if (obs.x + obs.width < player.x && !obs.passed) {
                score++;
                obs.passed = true;
                document.getElementById('score-display').innerText = `Score: ${score}`;
                if (!secretMode.active && score % 5 === 0) CONFIG.gameSpeed += 0.2;
            }
            if (obs.x + obs.width < -100) obstacles.splice(i, 1);
        }

        for (let i = coins.length - 1; i >= 0; i--) {
            let c = coins[i];
            c.x -= CONFIG.gameSpeed;
            const px = player.x + player.width/2;
            const py = player.y + player.height/2;
            const dx = px - c.x;
            const dy = py - c.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < c.radius + player.width/2) {
                score += c.value;
                document.getElementById('score-display').innerText = `Score: ${score}`;
                for(let j=0; j<5; j++) createParticle(c.x, c.y, 'spark');
                
                AudioSys.playSound('coin');
                
                scoreFloater.push({
                    x: c.x, y: c.y, 
                    text: "+" + c.value, 
                    life: 60, 
                    color: c.color,
                    vy: -2
                });
                coins.splice(i, 1);
                continue;
            }
            if (c.x < -50) coins.splice(i, 1);
        }

        for (let i = scoreFloater.length - 1; i >= 0; i--) {
            let f = scoreFloater[i];
            f.y += f.vy;
            f.life--;
            if(f.life <= 0) scoreFloater.splice(i, 1);
        }
        
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }

        goose.x += (goose.targetX - goose.x) * 0.05;
        goose.y += ((player.y - goose.y) * 0.02);
    }

  function startGame() {
        console.log("Start Button Clicked!"); 

        // 1. Audio Wake-up
        if (typeof AudioSys !== 'undefined') {
            AudioSys.init();
            if (AudioSys.ctx && AudioSys.ctx.state === 'suspended' && !AudioSys.isMuted) {
                AudioSys.ctx.resume();
            }
            AudioSys.playTrack('main');
            AudioSys.tempo = 1.45;
        }

        // 2. FORCE HIDE THE UI
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const mainTitle = document.getElementById('main-title');
        
        // Remove class AND force style to none
        if (startScreen) {
            startScreen.classList.remove('active');
            startScreen.style.display = 'none'; 
        }
        if (gameOverScreen) {
            gameOverScreen.classList.remove('active');
            gameOverScreen.style.display = 'none';
        }
        if (mainTitle) mainTitle.classList.add('hidden');
        
        // 3. Hide Characters
        const revImg = document.getElementById('start-rev-img');
        const gooseImg = document.getElementById('start-goose-img');
        if(revImg) revImg.style.display = 'none';
        if(gooseImg) gooseImg.style.display = 'none';
        
        document.body.classList.remove('blueprint-mode');
        
        // 4. Reset Game State
        player.baseX = canvas.width * 0.30;
        player.x = player.baseX;
        player.y = canvas.height / 2;
        player.velocity = 0;
        player.rotation = 0;
        
        goose.x = -150;
        goose.targetX = 70;
        
        obstacles = [];
        particles = [];
        clashCloudParticles = [];
        coins = [];
        scoreFloater = [];
        bgElements = [];
        for(let i=0; i<6; i++) createBgElement(Math.random() * canvas.width);

        score = 0;
        frames = 0;
        CONFIG.gameSpeed = 3.5; 
        
        secretMode.active = false;
        secretMode.timer = 0;
        battery.active = false;
        
        document.getElementById('score-display').innerText = `Score: ${score}`;
        
        isGameOver = false;
        isClashing = false;
        isPlaying = true;
        
        loop();
    }
    
    function loop() {
        if (isPlaying || isClashing) { 
            update(); 
            draw(); 
            requestAnimationFrame(loop); 
        } else if (isGameOver) { 
            draw(); 
        }
    }
    
    // --- EVENTS & BOOT ---
    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);
    
    window.addEventListener('resize', resize);
    window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') jump(); });
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, { passive: false });
    canvas.addEventListener('mousedown', (e) => { jump(); });

   window.onload = function() {
        resize(); // Ensure canvas is ready
        document.getElementById('loading').style.display = 'none';
        
        // Start screen music listener
        window.addEventListener('click', function musicStarter() {
            if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            
            // FIX: We check 'AUDIO_FILES', not 'CUSTOM_AUDIO'
            if (!AudioSys.isPlaying && AUDIO_FILES.music_start) {
                AudioSys.playTrack('start_screen');
            }
            
            window.removeEventListener('click', musicStarter);
        }, {once:true});
    };
    
</script>
</body>
</html>

































